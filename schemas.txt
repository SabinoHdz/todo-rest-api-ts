import mongoose from "mongoose";
const { Schema, model } = mongoose;

const userSchema = new Schema({
  name: { type: String, required: [true, "Name is required"] },
  email: { type: String, required: [true, "Email is required"], unique: true },
  password: { type: String, required: [true, "Password is required"] },
  img: { type: String },
  roles: {
    type: [String],
    default: ["USER_ROLE"],
    enum: ["USER_ROLE", "ADMIN_ROLE"],
  }
}, { timestamps: true });

export default model("User", userSchema);


import mongoose from "mongoose";
const { Schema, model, Types } = mongoose;

const userProfileSchema = new Schema({
  userId: { type: Types.ObjectId, ref: "User", unique: true, required: true },
  displayName: { type: String },
  avatarUrl: { type: String },
  timezone: { type: String, default: "UTC" },
  customStatusColors: [{
    statusId: { type: Types.ObjectId, ref: "TaskStatus", required: true },
    color: { type: String, required: true }
  }],
  customPriorityColors: [{
    priorityId: { type: Types.ObjectId, ref: "TaskPriority", required: true },
    color: { type: String, required: true }
  }]
}, { timestamps: true });

export default model("UserProfile", userProfileSchema);


import mongoose from "mongoose";
const { Schema, model } = mongoose;

const taskStatusSchema = new Schema({
  name: { type: String, required: true, unique: true },
  defaultColor: { type: String, default: "#ccc" }
}, { timestamps: true });

export default model("TaskStatus", taskStatusSchema);


import mongoose from "mongoose";
const { Schema, model } = mongoose;

const taskPrioritySchema = new Schema({
  name: { type: String, required: true, unique: true },
  defaultColor: { type: String, default: "#ccc" }
}, { timestamps: true });

export default model("TaskPriority", taskPrioritySchema);

import mongoose from "mongoose";
const { Schema, model, Types } = mongoose;

const tagSchema = new Schema({
  name: { type: String, required: true },
  color: { type: String, default: "#cccccc" },
  userId: { type: Types.ObjectId, ref: "User", required: true }
}, { timestamps: true });

tagSchema.index({ name: 1, userId: 1 }, { unique: true });

export default model("Tag", tagSchema);



import mongoose from "mongoose";
const { Schema, model, Types } = mongoose;

const taskSchema = new Schema({
  title: { type: String, required: true },
  description: { type: String },
  status: { type: Types.ObjectId, ref: "TaskStatus", required: true },
  priority: { type: Types.ObjectId, ref: "TaskPriority", required: true },
  tags: [{ type: Types.ObjectId, ref: "Tag" }],
  dueDate: { type: Date },
  completedAt: { type: Date },
  createdBy: { type: Types.ObjectId, ref: "User", required: true },
  history: [{
    change: String,
    changedAt: { type: Date, default: Date.now }
  }]
}, { timestamps: true });

export default model("Task", taskSchema);



#################üîπ A. Agregar un tag al array ($addToSet)



// PATCH /tasks/:taskId/tags/add
async function addTagToTask(req, res) {
  const { taskId } = req.params;
  const { tagId } = req.body;

  if (!tagId) return res.status(400).json({ error: "tagId is required" });

  try {
    const updatedTask = await TaskModel.findByIdAndUpdate(
      taskId,
      { $addToSet: { tags: tagId } }, // evita duplicados
      { new: true }
    );
    if (!updatedTask) return res.status(404).json({ error: "Task not found" });
    res.json(updatedTask);
  } catch (err) {
    res.status(500).json({ error: "Internal server error" });
  }
}

#############üîπ B. Eliminar un tag del array ($pull)

// PATCH /tasks/:taskId/tags/remove
async function removeTagFromTask(req, res) {
  const { taskId } = req.params;
  const { tagId } = req.body;

  if (!tagId) return res.status(400).json({ error: "tagId is required" });

  try {
    const updatedTask = await TaskModel.findByIdAndUpdate(
      taskId,
      { $pull: { tags: tagId } },
      { new: true }
    );
    if (!updatedTask) return res.status(404).json({ error: "Task not found" });
    res.json(updatedTask);
  } catch (err) {
    res.status(500).json({ error: "Internal server error" });
  }
}


###########‚öñÔ∏è 2. Comparaci√≥n: Actualizar todo el array vs solo agregar/quitar


| Aspecto                             | ‚úÖ Actualizar todo el array (`PUT`)                       | üîß Agregar/Eliminar individualmente (`PATCH`) |
| ----------------------------------- | -------------------------------------------------------- | --------------------------------------------- |
| üîÅ Reemplazo de array completo      | S√≠, debes enviar **todos los `tags` actuales**.          | No, solo el `tagId` a agregar o quitar.       |
| ‚úîÔ∏è Simplicidad del cliente          | Puede ser m√°s complejo (cliente debe mantener el array). | M√°s simple para operaciones peque√±as.         |
| üîç Control de cambios peque√±os      | No es eficiente para un solo cambio.                     | Ideal para cambios incrementales.             |
| üõ† Riesgo de sobrescribir por error | Alto si otro cliente modifica `tags` al mismo tiempo.    | Bajo, solo se toca un valor puntual.          |
| üîÑ Sincronizaci√≥n en tiempo real    | M√°s dif√≠cil mantener coherencia.                         | M√°s f√°cil y predecible.                       |
| üß© Escalabilidad                    | Buena para formularios completos.                        | Ideal para UI reactivas o acciones r√°pidas.   |


üìå ¬øCu√°l usar?
Si est√°s editando todo el task en un formulario completo, usa el enfoque de reemplazo.
Si tienes botones de "agregar/quitar tag" individuales (como etiquetas en una tarjeta estilo Trello), usa los endpoints separados.


#######cAMBIOS  en todos los campos

‚úÖ S√≠, puedes llamar a los endpoints de agregar/eliminar individualmente desde el frontend si el usuario est√° editando todo el task.

Cuando el usuario edita un task (por ejemplo en un formulario con checkboxes o etiquetas seleccionables), puedes:

Obtener los tags actuales del task desde la base de datos.
Comparar esos tags con los nuevos que seleccion√≥ el usuario.
Determinar:
Cu√°les agregar (nuevos tags no presentes antes).
Cu√°les eliminar (tags que estaban antes y ya no est√°n).
Hacer llamadas a los endpoints de agregar o eliminar solo para esos cambios.


‚ö†Ô∏è Consideraciones

Esto funciona bien cuando los cambios son peque√±os (agregar/quitar pocos tags).
Si el array completo cambia mucho (o el usuario borra todos y agrega muchos nuevos), puede ser m√°s eficiente hacer un solo PUT y enviar todos los nuevos tags.

‚úÖ ¬øCu√°ndo usar este enfoque?

| Situaci√≥n                                                      | Recomendaci√≥n                                                                          |
| -------------------------------------------------------------- | -------------------------------------------------------------------------------------- |
| Usuario edita un solo campo como `tags`                        | üëâ Usa `PATCH` individuales (agregar/quitar).                                          |
| Usuario edita todo el task en un solo formulario               | üëâ Puedes usar diff y llamar a varios `PATCH`, **o** enviar todo el array en un `PUT`. |
| Quieres evitar colisiones de datos (problemas de concurrencia) | üëâ Usa los `PATCH` individuales.                                                       |


##########################
 Estrategia propuesta (muy buena):

Cuando el usuario edita todo el task:
Comparas los tags actuales con los nuevos.
Si los nuevos son exactamente los mismos que los actuales (en orden o contenido), no haces nada.
Si los nuevos son diferentes, decides:
Si solo cambia 1 o 2 ‚Üí usa PATCH individuales (agrega o elimina).
Si cambia mucho ‚Üí usa un solo PUT y reemplaza todo el array.



üß† L√≥gica para comparar arrays (sin importar orden):


function areArraysEqual(a: string[], b: string[]): boolean {
  if (a.length !== b.length) return false;
  const aSorted = [...a].sort();
  const bSorted = [...b].sort();
  return aSorted.every((val, index) => val === bSorted[index]);
}


| Enfoque                 | Pros                        | Contras                                       |
| ----------------------- | --------------------------- | --------------------------------------------- |
| `PUT` con todo el array | M√°s simple, un solo request | Puede sobrescribir datos si no hay control    |
| `PATCH` por cambios     | Preciso, evita sobrescribir | M√°s requests, m√°s complejo de manejar errores |
| Mixto (tu estrategia)   | ‚úÖ Balance ideal             | Requiere m√°s l√≥gica                           |
